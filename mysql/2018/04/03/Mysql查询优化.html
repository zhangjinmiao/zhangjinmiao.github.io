<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>MySQL 查询优化 &mdash; 山川尽美</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangjinmiao/zhangjinmiao.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangjinmiao/zhangjinmiao.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangjinmiao/zhangjinmiao.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangjinmiao/zhangjinmiao.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangjinmiao/zhangjinmiao.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangjinmiao/zhangjinmiao.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangjinmiao/zhangjinmiao.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangjinmiao/zhangjinmiao.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangjinmiao/zhangjinmiao.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/pastie.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangjinmiao/zhangjinmiao.github.io@master/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="http://zhangjinmiao.github.io/mysql/2018/04/03/Mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96.html"><link rel="alternate" type="application/atom+xml" title="山川尽美" href="http://zhangjinmiao.github.io"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/zhangjinmiao/zhangjinmiao.github.io@master/favicon.ico"><meta property="og:title" content="MySQL 查询优化"><meta name="keywords" content="mysql, 优化"><meta name="og:keywords" content="mysql, 优化"><meta name="description" content="1. 数据库性能参数"><meta name="og:description" content="1. 数据库性能参数"><meta property="og:url" content="http://zhangjinmiao.github.io/mysql/2018/04/03/Mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96.html"><meta property="og:site_name" content="山川尽美"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2018-04-03"> <script src="https://cdn.jsdelivr.net/gh/zhangjinmiao/zhangjinmiao.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/zhangjinmiao/zhangjinmiao.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/zhangjinmiao/zhangjinmiao.github.io@master/assets/js/main.js"></script> <script data-ad-client="ca-pub-7093222719567591" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="http://zhangjinmiao.github.io/" title="山川尽美"><span class="octicon octicon-mark-github"></span> 山川尽美</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="http://zhangjinmiao.github.io/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="http://zhangjinmiao.github.io/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="http://zhangjinmiao.github.io/archives/" class=" site-header-nav-item" target="" title="归档">归档</a> <a href="http://zhangjinmiao.github.io/spring-boot.html" class=" site-header-nav-item" target="_blank" title="Spring Boot">Spring Boot</a> <a href="http://zhangjinmiao.github.io/payment.html" class=" site-header-nav-item" target="_blank" title="支付">支付</a> <a href="http://zhangjinmiao.github.io/about.html" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="MySQL 查询优化"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">MySQL 查询优化</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2018/04/03 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="http://zhangjinmiao.github.io/categories/#MySQL" title="MySQL">MySQL</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 6936 字，约 20 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"> <img style="height:72px;width:72px" src="https://cdn.jsdelivr.net/gh/zhangjinmiao/zhangjinmiao.github.io@master/assets/images/qrcode.jpg" alt="山川尽美" /></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths"><article class="article-content markdown-body"><h2 id="1-数据库性能参数">1. 数据库性能参数</h2><p><strong>查询 mysql 数据库的一些运行状态</strong></p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">show</span> <span class="n">status</span><span class="p">;</span> 
</code></pre></div></div><p><strong>查看操作次数</strong></p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">show</span> <span class="n">status</span> <span class="k">like</span> <span class="s1">'Com_(CRUD)'</span><span class="p">;</span>
</code></pre></div></div><p><strong>查看 mysql 数据库启动多长时间</strong>，myisam 存储引擎长时间启动需要进行碎片整理</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">show</span> <span class="n">status</span> <span class="k">like</span> <span class="s1">'uptime'</span><span class="p">;</span>
</code></pre></div></div><p><strong>查看慢查询</strong></p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">show</span> <span class="n">status</span> <span class="k">like</span> <span class="s1">'slow_queries'</span><span class="p">;</span>
</code></pre></div></div><p><strong>查询慢查询时间</strong></p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">'long_query_time'</span><span class="p">;</span>
</code></pre></div></div><p><strong>设置慢查询时间</strong></p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">set</span> <span class="n">long_query_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
</code></pre></div></div><h2 id="2-查询优化">2. 查询优化</h2><h3 id="21-查看-sql-执行计划">2.1 查看 SQL 执行计划</h3><p>使用命令：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">EXPLAIN</span><span class="o">/</span><span class="k">DESCRIBE</span><span class="o">/</span><span class="k">DESC</span> 
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span><span class="p">...;</span>
</code></pre></div></div><p><img src="https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/mysql/mysql-explain.png" alt="" /></p><p><img src="https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/mysql/explain.png" alt="" /></p><h3 id="22-每个字段说明"><strong>2.2 每个字段说明</strong></h3><p><strong>id</strong>：SELECT 标识符。这是 SELECT 的查询序列号。</p><p><strong>select_type：</strong>表示 SELECT 语句的类型。它可以是以下几种取值：</p><ol><li><p>SIMPLE：表示简单查询，其中不包括连接查询和子查询；</p></li><li><p>PRIMARY：表示主查询，或者最外层的查询语句；</p><p><img src="https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/mysql/PRIMARY.png" alt="" /></p></li><li><p>UNION：表示连接查询的第 2 个或后面的查询语句；</p><p><img src="https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/mysql/UNION.png" alt="" /></p></li><li><p>DEPENDENT UNION：连接查询中的第 2 个或后面的 SELECT 语句，取决于外面的查询；</p></li><li><p>UNION RESULT：连接查询的结果；</p></li><li><p>SUBQUERY：子查询中的第一个 SELECT 语句；</p><p><img src="https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/mysql/SUBQUERY.png" alt="" /></p></li><li><p>DEPENDENT SUBQUERY：子查询中的第一个 SELECT，取决于外面的查询；</p></li><li><p>DERIVED：导出表的 SELECT (FROM 语句的子查询）。</p></li></ol><p><strong>table：</strong>表示查询的表。</p><p><strong>type：</strong>（★重要★）表示表的连接类型。下面按照从最佳类型到最差类型的顺序给出各种连接类型：</p><ol><li><p>该表仅有一行的系统表。这是 const 连接类型的一个特例，平时不会出现，这个也可以忽略不计</p></li><li><p>const：</p><p>数据表最多只有一个匹配行，它将在查询开始时被读取，并在余下的査询优化中作为常量对待。const 表查询速度很快，因为它们只读取一次。const 用于使用常数值比较 PRIMARY KEY 或 UNIQUE 索引的所有部分的场合。 在下面查询中，tb1_name 可用 const 表：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>  <span class="o">*</span>  <span class="k">from</span> <span class="n">tb1_name</span> <span class="k">WHERE</span> <span class="n">primary_key</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="o">*</span> <span class="k">from</span> <span class="n">tb1_name</span> <span class="k">WHERE</span> <span class="n">primary_key_part1</span><span class="o">=</span><span class="mi">1</span> <span class="k">AND</span> <span class="n">primary_key_part2</span><span class="o">=</span><span class="mi">2</span>
</code></pre></div></div><p><img src="https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/mysql/const.png" alt="" /></p><p>​</p></li><li><p>eq_ref</p><p>mysql 手册是这样说的:”对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了 const 类型。它用在一个索引的所有部分被联接使用并且索引是 UNIQUE 或 PRIMARY KEY”。eq_ref 可以用于使用=比较带索引的列。</p><p>在下面例子中，MySQL 可以使用 eq_ref 来处理 ref_tables：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">ref_table</span><span class="p">,</span><span class="n">other_table</span> <span class="k">WHERE</span> <span class="n">ref_table</span><span class="p">.</span><span class="n">key_cloumn</span> <span class="o">=</span> <span class="n">other_table</span><span class="p">.</span><span class="n">cloumn</span><span class="p">;</span>
    <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">ref_table</span><span class="p">,</span> <span class="n">other_tbale</span> <span class="k">WHERE</span> <span class="n">ref_table</span><span class="p">.</span><span class="n">key_cloumn_part1</span> <span class="o">=</span> <span class="n">other_table</span><span class="p">.</span><span class="n">cloumn</span> <span class="k">AND</span> <span class="n">ref_table</span><span class="p">.</span><span class="n">key_cloumn_part2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div><p><img src="https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/mysql/eq_ref.png" alt="" /></p></li><li><p>ref</p><p>对于来自前面的表的任意组合，将从该表中读取所有匹配的行。这种类型用于索引既不是 UNIQUE 也不是 PRIMARY KEY 的情况，或者查询中使用了索引列在左子集，既索引中左边的部分列组合。ref 可以用于使用=或者&lt;=&gt;操作符的带索引的列。</p><p>以下的几个例子中，mysql 将使用 ref 来处理 ref_table：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">ref_table</span> <span class="k">where</span> <span class="n">key_column</span><span class="o">=</span><span class="n">expr</span><span class="p">;</span> 
 <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">ref_table</span><span class="p">,</span><span class="n">other_table</span> <span class="k">where</span> <span class="n">ref_table</span><span class="p">.</span><span class="n">key_column</span><span class="o">=</span><span class="n">other_table</span><span class="p">.</span><span class="k">column</span><span class="p">;</span> 
 <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">ref_table</span><span class="p">,</span><span class="n">other_table</span> <span class="k">where</span> <span class="n">ref_table</span><span class="p">.</span><span class="n">key_column_part1</span><span class="o">=</span><span class="n">other_table</span><span class="p">.</span><span class="k">column</span> <span class="k">and</span> <span class="n">ref_table</span><span class="p">.</span><span class="n">key_column_part2</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</code></pre></div></div><p><img src="https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/mysql/ref.png" alt="" /></p></li><li><p>ref_or_null</p><p>这种连接类型类似 ref，不同的是 mysql 会在检索的时候额外的搜索包含 null 值的记录。在解决子查询中经常使用该链接类型的优化。</p><p>在以下的例子中，mysql 使用 ref_or_null 类型来处理 ref_table：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">ref_table</span> <span class="k">where</span> <span class="n">key_column</span><span class="o">=</span><span class="n">expr</span> <span class="k">or</span> <span class="n">key_column</span> <span class="k">is</span> <span class="k">null</span><span class="p">;</span>
</code></pre></div></div><p><strong>上面这五种情况都是很理想的索引使用情况。</strong></p></li><li><p>index_merge</p><p>该链接类型表示使用了索引合并优化方法。在这种情况下，key 列包含了使用的索引的清单，key_len 包含了使用的索引的最长的关键元素。</p></li><li><p>unique_subquery</p><p>该类型替换了下面形式的 IN 子查询的 ref：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">value</span> <span class="k">in</span> <span class="p">(</span><span class="k">select</span> <span class="n">primary_key</span> <span class="k">from</span> <span class="n">single_table</span> <span class="k">where</span> <span class="n">some_expr</span><span class="p">)</span>
</code></pre></div></div></li><li><p>index_subquery</p><p>这种连接类型类似 unique_subquery。可以替换 IN 子查询，不过它用于在子查询中没有唯一索引的情况下， 例如以下形式：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">value</span> <span class="k">in</span> <span class="p">(</span><span class="k">select</span> <span class="n">key_column</span> <span class="k">from</span> <span class="n">single_table</span> <span class="k">where</span> <span class="n">some_expr</span><span class="p">)</span>
</code></pre></div></div></li><li><p>range</p><p>只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引。ken_len 包含所使用索引的最长关键元素。当使用 =, &lt;&gt;, &gt;,&gt;=, &lt;, &lt;=, is null, &lt;=&gt;, between, 或 in 操作符，用常量比较关键字列时，类型为 range。 下面介绍几种检索制定行的情况：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">tbl_name</span> <span class="k">where</span> <span class="n">key_column</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> 
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">tbl_name</span> <span class="k">where</span> <span class="n">key_column</span> <span class="k">between</span> <span class="mi">10</span> <span class="k">and</span> <span class="mi">20</span><span class="p">;</span> 
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">tbl_name</span> <span class="k">where</span> <span class="n">key_column</span> <span class="k">in</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">);</span> 
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">tbl_name</span> <span class="k">where</span> <span class="n">key_part1</span><span class="o">=</span> <span class="mi">10</span> <span class="k">and</span> <span class="n">key_part2</span> <span class="k">in</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">);</span>
</code></pre></div></div><p><img src="https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/mysql/range.png" alt="" /></p><p>​</p></li><li><p>index</p><p>连接类型跟 ALL 一样，不同的是它只扫描索引树。它通常会比 ALL 快点，因为索引文件通常比数据文件小。</p></li><li><p>ALL （性能最差）</p><p>对于前面的表的任意行组合，进行完整的表扫描。如果第一个表没有被标识为 const 的话就不大好了，在其他情况下通常是非常糟糕的。正常地，可以通过增加索引使得能从表中更快的取得记录以避免 ALL。</p></li></ol><p><strong>possible_keys</strong></p><p>possible_keys 字段是指 MySQL 在搜索表记录时可能使用哪个索引。如果这个字段的值是 NULL，就表示没有索引被用到。这种情况下，就可以检查 WHERE 子句中哪些字段哪些字段适合增加索引以提高查询的性能。创建一下索引，然后再用 explain 检查一下。</p><p><strong>key</strong></p><p>key 字段显示了 MySQL 实际上要用的索引。当没有任何索引被用到的时候，这个字段的值就是 NULL。想要让 MySQL 强行使用或者忽略在 possible_keys 字段中的索引列表，可以在查询语句中使用关键字 force index, use index 或 ignore index。参考 SELECT 语法。</p><p><img src="https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/mysql/key.png" alt="" /></p><p><strong>key_len</strong></p><p>​key_len 字段显示了 mysql 使用索引的长度。当 key 字段的值为 NULL 时，索引的长度就是 NULL。注意，key_len 的值可以告诉你在联合索引中 MySQL 会真正使用了哪些索引。</p><p><strong>ref</strong></p><p>​表示使用哪个列或常数与索引一起来查询记录。</p><p><strong>rows</strong></p><p>显示 MySQL 在表中进行查询时必须检查的行数。</p><p><strong>Extra</strong></p><p>本字段显示了查询中 mysql 的附加信息。以下是这个字段的几个不同值的解释：</p><blockquote><ul><li><p>distinct</p><p>MySQL 当找到当前记录的匹配联合结果的第一条记录之后，就不再搜索其他记录了。</p></li><li><p>not exists</p><p>MySQL 在查询时做一个 LEFT JOIN 优化时，当它在当前表中找到了和前一条记录符合 LEFT JOIN 条件后，就不再搜索更多的记录了。下面是一个这种类型的查询例子：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="k">left</span> <span class="k">join</span> <span class="n">t2</span> <span class="k">on</span> <span class="n">t1</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">t2</span><span class="p">.</span><span class="n">id</span> <span class="k">where</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span> <span class="k">is</span> <span class="k">null</span><span class="p">;</span>
</code></pre></div></div><p>假使 t2.id 定义为 not null。这种情况下，MySQL 将会扫描表 t1 并且用 t1.id 的值在 t2 中查找记录。当在 t2 中找到一条匹配的记录时，这就意味着 t2.id 肯定不会都是 null，就不会再在 t2 中查找相同 id 值的其他记录了。也可以这么说，对于 t1 中的每个记录，mysql 只需要在 t2 中做一次查找，而不管在 t2 中实际有多少匹配的记录。</p></li><li><p>range checked for each record (index map: #)</p><p>MySQL 没找到合适的可用的索引。取代的办法是，对于前一个表的每一个行连接，它会做一个检验以决定该使用哪个索引（如果有的话），并且使用这个索引来从表里取得记录。这个过程不会很快，但总比没有任何索引时做表连接来得快。</p></li><li><p>using filesort</p></li></ul><p>MySQL 需要额外的做一遍从已排好的顺序取得记录。排序程序根据连接的类型遍历所有的记录，并且将所有符合 where 条件的记录的要排序的键和指向记录的指针存储起来。这些键已经排完序了，对应的记录也会按照排好的顺序取出来。</p><ul><li>using index</li></ul><p>字段的信息直接从索引树中的信息取得，而不再去扫描实际的记录。这种策略用于查询时的字段是一个独立索引的一部分。</p><ul><li>using temporary</li></ul><p>MySQL 需要创建临时表存储结果以完成查询。这种情况通常发生在查询时包含了 group by 和 order by 子句，它以不同的方式列出了各个字段。</p><ul><li>using where</li></ul><p>where 子句将用来限制哪些记录匹配了下一个表或者发送给客户端。除非你特别地想要取得或者检查表中的所有记录，否则的话当查询的 extra 字段值不是 using where 并且表连接类型是 all 或 index 时可能表示有问题。</p><ul><li>Using sort_union(…), Using union(…), Using intersect(…)</li></ul><p>这些函数说明如何为 index_merge 联接类型合并索引扫描</p><ul><li>Using index for group-by</li></ul><p>类似于访问表的 Using index 方式,Using index for group-by 表示 MySQL 发现了一个索引,可以用来查 询 GROUP BY 或 DISTINCT 查询的所有列,而不要额外搜索硬盘访问实际的表。</p></blockquote><p>如果你想要让查询尽可能的快，那么就应该注意 extra 字段的值为 using filesort 和 using temporary 的情况。 说明 SQL 需要优化了。</p><h3 id="23使用索引查询需要注意">2.3 使用索引查询需要注意</h3><p>索引可以提供查询的速度，但并不是使用了带有索引的字段查询都会生效，有些情况下是不生效的，需要注意。</p><h4 id="231-使用-like-关键字的查询">2.3.1 使用 LIKE 关键字的查询</h4><p>在使用 LIKE 关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不起作用。只有“%”不在第一个位置，索引才会生效。</p><p><img src="https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/mysql/like1.png" alt="" /></p><p><img src="https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/mysql/like2.png" alt="" /></p><h4 id="232-使用联合索引的查询">2.3.2 使用联合索引的查询</h4><p>MySQL 可以为多个字段创建索引，一个索引可以包括 16 个字段。对于联合索引，只有查询条件中使用了这些字段中第一个字段时，索引才会生效。</p><p><img src="https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/mysql/index1.png" alt="" /></p><p><img src="https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/mysql/index2.png" alt="" /></p><p><img src="https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/mysql/index3.png" alt="" /></p><h4 id="233-使用-or-关键字的查询">2.3.3 使用 OR 关键字的查询</h4><p>查询语句的查询条件中只有 OR 关键字，且 OR 前后的两个条件中的列都是索引时，索引才会生效，否则，索引不生效。</p><p><img src="https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/mysql/or1.png" alt="" /><img src="https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/mysql/or2.png" alt="" /></p><p><img src="https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/mysql/or3.png" alt="" /></p><h3 id="24-子查询优化">2.4 子查询优化</h3><p>MySQL 从 4.1 版本开始支持子查询，使用子查询进行 SELECT 语句嵌套查询，可以一次完成很多逻辑上需要多个步骤才能完成的 SQL 操作。</p><p>子查询虽然很灵活，但是执行效率并不高。</p><p>执行子查询时，MYSQL 需要创建临时表，查询完毕后再删除这些临时表，所以，子查询的速度会受到一定的影响。</p><p> </p><p><strong>优化：</strong></p><p>可以使用连接查询（JOIN）代替子查询，连接查询时不需要建立临时表，其速度比子查询快。</p><h2 id="3-数据库结构优化">3. 数据库结构优化</h2><p>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</p><p>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p><h3 id="31-将字段很多的表分解成多个表">3.1 将字段很多的表分解成多个表</h3><p>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</p><p>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p><h3 id="32-增加中间表">3.2 增加中间表</h3><p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</p><p>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</p><h3 id="33-增加冗余字段">3.3 增加冗余字段</h3><p>设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</p><p>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</p><p><strong>注意：</strong></p><p><strong>冗余字段的值在一个表中修改，就要想办法在其他表中更新，否则就会导致数据不一致的问题。</strong></p><h2 id="4-插入数据的优化">4. 插入数据的优化</h2><p>插入数据时，影响插入速度的主要是<code class="language-plaintext highlighter-rouge">索引</code>、<code class="language-plaintext highlighter-rouge">唯一性校验</code>、<code class="language-plaintext highlighter-rouge">一次插入的数据条数</code>等。 </p><p>插入数据的优化，不同的存储引擎优化手段不一样，在 MySQL 中常用的存储引擎有，MyISAM 和 InnoDB，两者的区别：</p><p>参考：http://www.cnblogs.com/panfeng412/archive/2011/08/16/2140364.html</p><p><img src="https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/mysql/insert.png" alt="" /></p><h3 id="41-myisam">4.1 MyISAM</h3><h4 id="411-禁用索引">4.1.1 禁用索引</h4><p>对于非空表，插入记录时，MySQL 会根据表的索引对插入的记录建立索引。如果插入大量数据，建立索引会降低插入数据速度。</p><p>为了解决这个问题，可以在批量插入数据之前禁用索引，数据插入完成后再开启索引。</p><p>禁用索引的语句：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="k">table_name</span> <span class="n">DISABLE</span> <span class="n">KEYS</span>
</code></pre></div></div><p>开启索引语句：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="k">table_name</span> <span class="n">ENABLE</span> <span class="n">KEYS</span>
</code></pre></div></div><p>对于空表批量插入数据，则不需要进行操作，因为 MyISAM 引擎的表是在导入数据后才建立索引。</p><h4 id="412-禁用唯一性检查">4.1.2 禁用唯一性检查</h4><p>唯一性校验会降低插入记录的速度，可以在插入记录之前禁用唯一性检查，插入数据完成后再开启。</p><p> </p><p>禁用唯一性检查的语句：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SET</span> <span class="n">UNIQUE_CHECKS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="err"> </span>
</code></pre></div></div><p>开启唯一性检查的语句:</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SET</span> <span class="n">UNIQUE_CHECKS</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div><h4 id="413-批量插入数据">4.1.3 批量插入数据</h4><p>插入数据时，可以使用一条 INSERT 语句插入一条数据，也可以插入多条数据。</p><p><img src="https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/mysql/fs1.png" alt="" /></p><p><img src="https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/mysql/fs2.png" alt="" /></p><p>第二种方式的插入速度比第一种方式快。</p><h4 id="414-使用-load-data-infile">4.1.4 使用 LOAD DATA INFILE</h4><p>当需要批量导入数据时，使用 LOAD DATA INFILE 语句比 INSERT 语句插入速度快很多。</p><h3 id="42-innodb">4.2 InnoDB</h3><h4 id="421-禁用唯一性检查">4.2.1 禁用唯一性检查</h4><p>用法和 MyISAM 一样。</p><h4 id="422-禁用外键检查">4.2.2 禁用外键检查</h4><p>插入数据之前执行禁止对外键的检查，数据插入完成后再恢复，可以提供插入速度。</p><p>禁用：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SET</span> <span class="n">foreign_key_checks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div><p>开启：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SET</span> <span class="n">foreign_key_checks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div><h4 id="423-禁止自动提交">4.2.3 禁止自动提交</h4><p>插入数据之前执行禁止事务的自动提交，数据插入完成后再恢复，可以提高插入速度。</p><p> 禁用：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SET</span> <span class="n">autocommit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div><p>开启：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SET</span> <span class="n">autocommit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div><h2 id="5-服务器优化">5. 服务器优化</h2><h3 id="51-优化服务器硬件">5.1 优化服务器硬件</h3><p>服务器的硬件性能直接决定着 MySQL 数据库的性能，硬件的性能瓶颈，直接决定 MySQL 数据库的运行速度和效率。</p><p> </p><p>需要从以下几个方面考虑：</p><p>1、 配置较大的内存。足够大的内存，是提高 MySQL 数据库性能的方法之一。内存的 IO 比硬盘快的多，可以增加系统的缓冲区容量，使数据在内存停留的时间更长，以减少磁盘的 IO。</p><p>2、 配置高速磁盘，比如 SSD。</p><p>3、 合理分配磁盘 IO，把磁盘 IO 分散到多个设备上，以减少资源的竞争，提高并行操作能力。</p><p>4、 配置多核处理器，MySQL 是多线程的数据库，多处理器可以提高同时执行多个线程的能力。</p><h3 id="52-优化-mysql-参数">5.2 优化 MySQL 参数</h3><p>通过优化 MySQL 的参数可以提高资源利用率，从而达到提高 MySQL 服务器性能的目的。</p><p>MySQL 的配置参数都在 my.conf 或者 my.ini 文件的 [mysqld] 组中，常用的参数如下：</p><p><img src="https://github.com/zhangjinmiao/zhangjinmiao.github.io/raw/master/assets/images/2018/mysql/cs.png" alt="" /></p><h2 id="6-优化-limit-分页">6. 优化 LIMIT 分页</h2><p>在分页偏移量很大的时候，如 LIMIT 10000,20 这样的查询，MySQL 需要查询 10020 条记录然后只返回最后 20 条，前面 10000 条记录都被抛弃，这样代价非常高。</p><p>优化的最简单的办法就是尽可能地使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列，对于偏移量很大的时候，这样做的效率回提升很大，如下：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">file_id</span><span class="p">,</span> <span class="n">description</span> <span class="k">FROM</span> <span class="n">film</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">title</span> <span class="k">LIMIT</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">5</span><span class="p">;</span>
</code></pre></div></div><p>修改为：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">film</span><span class="p">.</span><span class="n">film_id</span><span class="p">,</span> <span class="n">film</span><span class="p">.</span><span class="n">description</span> <span class="k">FROM</span> <span class="n">film</span><span class="err"> </span>

<span class="k">INNER</span> <span class="k">JOIN</span> <span class="p">(</span><span class="n">SELCT</span> <span class="n">film_id</span> <span class="k">FROM</span> <span class="n">film</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">title</span> <span class="k">LIMIT</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="k">AS</span> <span class="n">lim</span> <span class="k">USING</span><span class="p">(</span><span class="n">film_id</span><span class="p">);</span>
</code></pre></div></div><p>这里“延迟关联”将大大提升查询效率，它让 MySQL 扫描尽可能少的页面，获取需要访问的记录后在根据关联列回原表查询需要的所有列。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="http://zhangjinmiao.github.io" target="_blank">Zhang jinmiao</a></li><li>本文链接：<a href="http://zhangjinmiao.github.io/mysql/2018/04/03/Mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96.html" target="_blank">http://zhangjinmiao.github.io/mysql/2018/04/03/Mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96.html</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"><div class="share-component" data-disabled='qq,facebook'></div></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="zhangjinmiao/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/zhangjinmiao/zhangjinmiao.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/zhangjinmiao/zhangjinmiao.github.io@built/assets/search_data.json?v=1660720055', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/zhangjinmiao/zhangjinmiao.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Zhang jinmiao">Zhang jinmiao</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/zhangjinmiao/zhangjinmiao.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="http://zhangjinmiao.github.io/links.html" title="链接" target="_blank">链接</a></li><li> <a href="http://zhangjinmiao.github.io/used-urls.html" title="网址" target="_blank">网址</a></li><li> <a href="http://zhangjinmiao.github.io/money.html" title="挣钱" target="_blank">挣钱</a></li><li> <a href="http://zhangjinmiao.github.io/todo.html" title="TODO" target="_blank">TODO</a></li><li> <a href="http://zhangjinmiao.github.io/open-source.html" title="Code" target="_blank">Code</a></li><li><a href="http://zhangjinmiao.github.io"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div><div class="site-footer" role="contentinfo" style="padding-top:0px;border-top:none;"><div style="text-align:center;"> <a target="_blank" style="color:#777" href="http://beian.miit.gov.cn/">晋ICP备19009201号-1</a></div><div style="text-align:center"> <img src="http://zhangjinmiao.github.io/assets/images/2019/备案图标.png"> <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010802029536" style="display:inline-block;text-decoration:none;height:20px;line-height:20px;"><img src="" style="float:left;"/><p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;">京公网安备 11010802029536号</p></a></div><div class="mobile-hidden" style="text-align:center;" > <span id="busuanzi_container_site_pv">本站总访问量:<span id="busuanzi_value_site_pv"></span>次/</span> <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人/</span> <span id="busuanzi_container_page_pv">本页访问量<span id="busuanzi_value_page_pv"></span>次/</span> 统计始于2018-03-12 <span id="htmer_time"></span></div><script async src="https://cdn.jsdelivr.net/gh/zhangjinmiao/zhangjinmiao.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script> <script language=JavaScript> function secondToDate(second) { if (!second) { return 0; } var time = new Array(0, 0, 0, 0, 0); if (second >= 365 * 24 * 3600) { time[0] = parseInt(second / (365 * 24 * 3600)); second %= 365 * 24 * 3600; } if (second >= 24 * 3600) { time[1] = parseInt(second / (24 * 3600)); second %= 24 * 3600; } if (second >= 3600) { time[2] = parseInt(second / 3600); second %= 3600; } if (second >= 60) { time[3] = parseInt(second / 60); second %= 60; } if (second > 0) { time[4] = second; } return time; } </script> <script type="text/javascript" language="javascript"> function setTime() { var create_time = Math.round(new Date(Date.UTC(2018, 3, 12, 0, 0, 0)).getTime() / 1000); var timestamp = Math.round((new Date().getTime() + 8 * 60 * 60 * 1000) / 1000); currentTime = secondToDate((timestamp - create_time)); currentTimeHtml = '默默运行了' + currentTime[0] + '年' + currentTime[1] + '天' + currentTime[2] + '时' + currentTime[3] + '分' + currentTime[4] + '秒'; document.getElementById("htmer_time").innerHTML = currentTimeHtml; } setInterval(setTime, 1000); </script></div></footer><script src="https://cdn.jsdelivr.net/gh/zhangjinmiao/zhangjinmiao.github.io@master/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/zhangjinmiao/zhangjinmiao.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
