---
layout: post
title: Redis 简介
categories: Redis
description: redis 系列学习开篇
keywords: redis
---

## 1. 什么是redis

Redis—— Remote Dictionary Server，它是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API，我们可使用它构建高性能，可扩展的Web应用程序。

Redis是目前最流行的键值对存储数据库，从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。

如果你想了解Redis最新的资讯，可以访问 

- [官方网站](http://redis.io/) 
- [Redis作者博客](http://antirez.com/latest/0)


- [中文社区](http://www.redis.cn/)


- [huangz/blog](http://blog.huangz.me/index.html)

- [gitchat 购买的课程](http://gitbook.cn/books/5a196cb24a97251edce2ae9a/index.html)

  ​



## 2. **特点**

相对于其他的同类型数据库而言，Redis 支持更多的数据类型，除了和 string 外，还支持  lists（列表）、sets（集合）和 zsets（有序集合），hash 几种数据类型。  这些数据类型都支持 push/pop、add/remove 及取交集、并集和差集及更丰富的操作，而且这些操作都是原子性的。Redis 具备以下**特点**：  

1. **异常快速：**

   Redis 数据库完全在内存中，因此处理速度非常快，单机qps（每秒的并发）可以达到的速度是110000次/s，写的速度是81000次/s，适合小数据量高速读写访问。

   ​

2. **数据持久化：** 

   redis 支持数据持久化，可以将内存中的数据存储到磁盘上，方便在宕机等突发情况下快速恢复。 


   > **方式一（RDB）：**根据指定的规则，**定时周期性**的把内存中更新的数据写入到磁盘里。RDB的方式是通过快照（snapshot）完成，当符合规则时redis会把内存的数据生成一个副本并存储在硬盘中，这个过程称之为“快照”。
   >
   > **方式二（AOF）：**把修改的操作记录追加到文件里，默认情况redis没有开启AOF方式，可以通过appendonly命令来启用，如：appendonly yes。
   >
   > 
   >
   > **两种方式的区别**：RDB方式性能较高，但是可能会引起一定程度的数据丢失，AOF方式正好相反。

   

1. **支持丰富的数据类型：** 

   Redis不仅仅支持简单的key-value类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。 

   ​

2. **单进程单线程高性能服务器**：启动一个实例只能用一个CPU，所以用Redis可以用多个实例，一个实例用一个CPU以便提高效率。

   ​

3. **crash safe 和 recovery slow**

   redis 崩溃后，数据相对安全，但是恢复起来比较缓慢，所以生产环境不建议一个Redis实例数据太多{（20-30）G数据内存对应（96-128）G实际内存）}，这种20%-23%的比例比较合适，因为磁盘读到内存的恢复时间也很慢，可以使用ssd磁盘来提高磁盘读取速度。

   ​

4. **数据一致性：**

    所有 Redis 操作是 ***原子*** 的，这保证了如果两个客户端同时访问的 Redis 服务器将获得更新后的值。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。

   ​

   ​

5. **多功能实用工具：** 

   Redis 是一个多实用的工具，可以在多个用例如缓存，消息，队列使用(Redis 原生支持发布/订阅)，任何短暂的数据，应用程序，如 Web 应用程序会话，网页命中计数等。

   ​

6. **Redis支持数据的备份：**

   即 master-slave 模式的数据备份。

   ​

   ​

## 3. Redis缺陷与陷阱 

内存管理开销大（不要超过物理内存的3/5）。buffer io 可能会造成系统内存溢出（OOM-Out of Memory）。





## 4. 应用场景

在实际生产环境中，很多公司都曾经使用过这样的架构，使用MySQL进行海量数据存储的，通过Memcached将热点数据加载到cache，加速访问，但随着业务数据量的不断增加，和访问量的持续增长，我们遇到了很多问题：

- MySQL需要不断进行拆库拆表，Memcached也需不断跟着扩容，扩容和维护工作占据大量开发时间。
- Memcached与MySQL数据库数据一致性问题。
- Memcached数据命中率低或down机，大量访问直接穿透到DB，MySQL无法支撑。
- 跨机房cache同步问题。

以上问题都是非常的棘手，不过现在不用担心了，因为我们可以使用redis来完美解决。



1. **会话缓存（Session Cache）**
   Redis 缓存会话有非常好的优势，因为 Redis 提供持久化，在需要长时间保持会话的应用场景中，如购物车场景这样的场景中能提供很好的长会话支持，能给用户提供很好的购物体验。

2. **全页缓存**
   在 WordPress 中，Pantheon 提供了一个不错的插件`wp-redis`，这个插件能以最快的速度加载你曾经浏览过的页面。

3. **队列**
   Reids 提供 list 和 set 操作，这使得 Redis 能作为一个很好的消息队列平台来使用。

   我们常通过 Reids 的队列功能做购买限制。比如到节假日或者推广期间，进行一些活动，对用户购买行为进行限制，限制今天只能购买几次商品或者一段时间内只能购买一次，也比较适合适用。

4. **排名**
   Redis 在内存中对数字进行递增或递减的操作实现得非常好。所以我们在很多排名的场景中会应用 Redis 来进行，比如小说网站对小说进行排名，根据排名，将排名靠前的小说推荐给用户。

5. **发布/订阅**
   Redis 提供发布和订阅功能，发布和订阅的场景很多，比如我们可以基于发布和订阅的脚本触发器，实现用Redis 的发布和订阅功能建立起来的聊天系统。





## 5.  Redis与其他key-value存储有什么不同？

Redis 有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis 的数据类型都是基于**基本数据结构**的，同时对程序员透明，无需进行额外的抽象。

Redis 运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， 相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样 Redis 可以做很多内部复杂性很强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。



## 6. **Redis集群简单介绍** 

Redis有3种集群策略

1. 主从

   1台机器可写作为主，另外2台可读，作为从，类似于MySQL的主从复制，不过Redis没有BINLOG机制。

2. 哨兵

   增加一台机器作为哨兵，监控3台主从机器，当主节点挂机的时候，机器内部进行选举，从集群中从节点里指定一台机器升级为主节点，从而实现高可用。当主节点恢复的时候，加入到从节点中继续提供服务。

3. 集群

   Redis3.0以后增加了集群的概念，可以实现多主多从结构，实现正真的高可用。




## 7. 事务

Redis 支持简单的事务。

 

**Redis与 mysql事务的对比** 

|      | Mysql             | Redis      |
| ---- | ----------------- | ---------- |
| 开启   | start transaction | muitl      |
| 语句   | 普通sql             | 普通命令       |
| 失败   | rollback 回滚       | discard 取消 |
| 成功   | commit            | exec       |

 

注: rollback与discard 的区别

如果已经成功执行了2 条语句， 第 3 条语句出错

> Rollback 后,前 2 条的语句影响消失
>
> Discard 只是结束本次事务，前 2 条语句造成的影响仍然还在

 

**注:**

在 mutil 后面的语句中, 语句出错可能有 2 种情况

1: 语法就有问题, 

这种,exec 时,报错, 所有语句得不到执行

 

2: 语法本身没错,但适用对象有问题. 比如 zadd 操作 list 对象

Exec 之后,会执行正确的语句,并跳过有不适当的语句。



**例子：**

我正在买票

Ticket -1 , money -100

而票只有1张, 如果在我 multi 之后,和 exec 之前, 票被别人买了---即 ticket 变成 0 了

**我该如何观察这种情景,并不再提交？**

 

悲观的想法: 

世界充满危险,肯定有人和我抢, 给 ticket上锁, 只有我能操作。[悲观锁]

 

乐观的想法:

没有那么人和我抢,因此,我只需要注意，

有没有人更改ticket的值就可以了 [乐观锁]



**Redis的事务中,启用的是乐观锁,只负责监测key没有被改动**



具体的命令----  watch命令

例: 

````shell
redis 127.0.0.1:6379> watch ticket
OK
redis 127.0.0.1:6379> multi
OK
redis 127.0.0.1:6379> decr ticket
QUEUED
redis 127.0.0.1:6379> decrby money 100
QUEUED
redis 127.0.0.1:6379> exec
(nil)   // 返回nil,说明监视的ticket已经改变了,事务就取消了.
redis 127.0.0.1:6379> get ticket
"0"
redis 127.0.0.1:6379> get money
"200"
````



- **watch key1 key2  ... keyN**

作用：监听key1 key2..keyN有没有变化,如果有变, 则事务取消

- **unwatch** 

作用: 取消所有watch监听

